const hre = require("hardhat");
const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");
const { buildPoseidon } = require("circomlibjs"); // REQUIRED

async function main() {
  console.log("Starting Admin Private Voting Registration (Poseidon + Depth 6)...\n");

  const DID_REGISTRY_ADDR = process.env.DID_REGISTRY_ADDRESS;
  const PRIVATE_VOTING_ADDR = process.env.PRIVATE_DAO_VOTING_ADDRESS;

  if (!DID_REGISTRY_ADDR || !PRIVATE_VOTING_ADDR) {
    console.error("Missing contract addresses in .env");
    process.exit(1);
  }

  // Admin is both the Voter AND the Trusted Issuer for this test
  const [admin] = await hre.ethers.getSigners();
  console.log("Admin Address:", admin.address);
  console.log("DIDRegistry:", DID_REGISTRY_ADDR);
  console.log("PrivateDAOVoting:", PRIVATE_VOTING_ADDR);

  const DIDRegistry = await hre.ethers.getContractAt("DIDRegistry", DID_REGISTRY_ADDR);
  const PrivateDAOVoting = await hre.ethers.getContractAt("PrivateDAOVoting", PRIVATE_VOTING_ADDR);

  // --- 1. SETUP POSEIDON ---
  const poseidon = await buildPoseidon();
  const F = poseidon.F; // Field arithmetic

  // Helper to match Frontend Logic
  const stringToNumber = (str) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  };

  // --- 2. GENERATE IDENTITY (SECRET & COMMITMENT) ---
  const SECRET_STRING = "Yasuri"; // Change this if you want
  const SECRET_NUMBER = stringToNumber(SECRET_STRING);
  
  console.log("\nðŸ” Generating Identity...");
  // FIX: Use Poseidon Hash for Commitment
  const poseidonHash = poseidon([SECRET_NUMBER]);
  const commitment = "0x" + BigInt(F.toString(poseidonHash)).toString(16).padStart(64, "0");
  
  console.log("Secret String:", SECRET_STRING);
  console.log("Commitment (Poseidon):", commitment);

  // --- 3. GENERATE ISSUER SIGNATURE ---
  // Since we are the admin, we likely set ourselves as the 'Trusted Issuer' in the constructor.
  // We sign our own address to approve ourselves.
  console.log("\nâœï¸  Generating Issuer Signature...");
  
  const messageHash = ethers.solidityPackedKeccak256(["address"], [admin.address]);
  const messageBytes = ethers.getBytes(messageHash);
  const signature = await admin.signMessage(messageBytes);
  
  console.log("Signature:", signature);

  // --- 4. REGISTER ON CHAIN ---
  // Check Sybil
  const hasRegistered = await DIDRegistry.hasRegisteredForVoting(admin.address);
  
  if (hasRegistered) {
    console.log("Already registered. Skipping transaction.");
  } else {
    console.log("\nðŸ“ Registering on Blockchain...");
    // FIX: Pass Signature
    const tx = await DIDRegistry.registerVoterForDAO(commitment, signature);
    await tx.wait();
    console.log("Registration Confirmed!");
  }

  // --- 5. BUILD MERKLE TREE (OFF-CHAIN CALCULATION) ---
  const MERKLE_TREE_DEPTH = 6; // FIX: Depth 6
  console.log(`\nðŸŒ³ Building Merkle Tree (Depth ${MERKLE_TREE_DEPTH})...`);
  
  // Get all commitments
  const commitmentsArr = await PrivateDAOVoting.getAllVoterCommitments();
  
  // Convert to BigInts for Poseidon
  let leaves = commitmentsArr.map(c => BigInt(c));
  
  // Pad with Zero Hashes (0)
  const targetSize = 2 ** MERKLE_TREE_DEPTH;
  while (leaves.length < targetSize) {
    leaves.push(0n);
  }

  // Calculate Tree
  let currentLevel = leaves;
  for (let i = 0; i < MERKLE_TREE_DEPTH; i++) {
    const nextLevel = [];
    for (let j = 0; j < currentLevel.length; j += 2) {
      const left = currentLevel[j];
      const right = currentLevel[j + 1];
      // FIX: Use Poseidon for Tree Nodes
      const hash = poseidon([left, right]); 
      nextLevel.push(BigInt(F.toString(hash)));
    }
    currentLevel = nextLevel;
  }

  const merkleRootBigInt = currentLevel[0];
  const merkleRootHex = "0x" + merkleRootBigInt.toString(16).padStart(64, "0");
  
  console.log("Calculated Root:", merkleRootHex);

  // --- 6. UPDATE ROOT ON CONTRACT ---
  const currentContractRoot = await PrivateDAOVoting.currentVoterSetRoot();
  
  // Compare normalized lowercase strings
  if (currentContractRoot.toLowerCase() !== merkleRootHex.toLowerCase()) {
    console.log("ðŸ”„ Updating Root on Contract...");
    const txRoot = await PrivateDAOVoting.updateVoterSetRoot(merkleRootHex);
    await txRoot.wait();
    console.log("Root Synced!");
  } else {
    console.log("Root is already up to date.");
  }

  // --- 7. SAVE SECRET FILE ---
  const secretData = {
    secret: SECRET_STRING,
    commitment: commitment,
    merkleRoot: merkleRootHex,
    address: admin.address,
    timestamp: new Date().toISOString(),
    note: "Generated by register-admin-voter.js"
  };

  const secretsDir = path.join(__dirname, "../secrets");
  if (!fs.existsSync(secretsDir)) fs.mkdirSync(secretsDir, { recursive: true });
  
  const filename = path.join(secretsDir, `admin-secret.json`);
  fs.writeFileSync(filename, JSON.stringify(secretData, null, 2));
  console.log(`\n Secret saved to: ${filename}`);
  console.log("DONE.");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });