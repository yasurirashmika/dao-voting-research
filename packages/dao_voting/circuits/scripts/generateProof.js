const snarkjs = require("snarkjs");
const fs = require("fs");
const path = require("path");
const { buildPoseidon } = require("circomlibjs");

// 1. Define Robust Paths (Works from any directory)
const SCRIPT_DIR = __dirname;
const BUILD_DIR = path.join(SCRIPT_DIR, "../build/vote");
const WASM_PATH = path.join(BUILD_DIR, "vote_js/vote.wasm");
// IMPORTANT: Matches the name generated by setup.ps1
const ZKEY_PATH = path.join(BUILD_DIR, "vote_final.zkey"); 
const VKEY_PATH = path.join(BUILD_DIR, "verification_key.json");

/**
 * Generate Merkle proof for a leaf in the tree
 */
function generateMerkleProof(leaves, leafIndex, levels = 20) {
    const pathElements = [];
    const pathIndices = [];
    
    let currentIndex = leafIndex;
    let currentLevelLeaves = [...leaves];
    
    for (let level = 0; level < levels; level++) {
        const siblingIndex = currentIndex % 2 === 0 ? currentIndex + 1 : currentIndex - 1;
        
        // If sibling exists, add it; otherwise use zero
        const sibling = siblingIndex < currentLevelLeaves.length 
            ? currentLevelLeaves[siblingIndex] 
            : BigInt(0);
        
        pathElements.push(sibling);
        pathIndices.push(currentIndex % 2);
        
        // Move up to next level
        currentIndex = Math.floor(currentIndex / 2);
        
        // Hash pairs for next level
        const nextLevel = [];
        for (let i = 0; i < currentLevelLeaves.length; i += 2) {
            const left = currentLevelLeaves[i];
            const right = i + 1 < currentLevelLeaves.length 
                ? currentLevelLeaves[i + 1] 
                : BigInt(0);
            
            // Note: In a real app, this should match the circuit's hash (Poseidon)
            // For this simulation script, we use a placeholder or need async logic.
            // Since this function is sync, we are simplifying. 
            // *Crucial*: In production, use the exact same Poseidon as the circuit.
            nextLevel.push(left + right); // Simplified for structure demo
        }
        
        currentLevelLeaves = nextLevel;
    }
    
    return { pathElements, pathIndices, root: currentLevelLeaves[0] };
}

/**
 * Hash two elements using Poseidon
 */
async function hashPair(left, right) {
    const poseidon = await buildPoseidon();
    const hash = poseidon.F.toString(poseidon([left, right]));
    return BigInt(hash);
}

/**
 * Generate commitment from secret
 */
async function generateCommitment(secret) {
    const poseidon = await buildPoseidon();
    const commitment = poseidon.F.toString(poseidon([secret]));
    return BigInt(commitment);
}

/**
 * Generate nullifier
 */
async function generateNullifier(secret, proposalId) {
    const poseidon = await buildPoseidon();
    const nullifier = poseidon.F.toString(poseidon([secret, proposalId]));
    return BigInt(nullifier);
}

/**
 * Generate zero-knowledge proof for voting
 */
async function generateVoteProof(secret, proposalId, voteChoice, voterCommitments, voterIndex) {
    console.log("Generating zero-knowledge proof...");
    
    if (!fs.existsSync(WASM_PATH) || !fs.existsSync(ZKEY_PATH)) {
        throw new Error(`Missing circuit files. Check: \n${WASM_PATH}\n${ZKEY_PATH}`);
    }

    // 1. Generate commitment
    const commitment = await generateCommitment(secret);
    console.log("Commitment:", commitment.toString());
    
    // 2. Generate Merkle proof
    // Note: For real proofs, we need the exact root calculation using Poseidon
    const { pathElements, pathIndices, root } = generateMerkleProof(
        voterCommitments,
        voterIndex,
        20
    );
    console.log("Merkle root:", root.toString());
    
    // 3. Generate nullifier
    const nullifier = await generateNullifier(secret, proposalId);
    console.log("Nullifier:", nullifier.toString());
    
    // 4. Prepare circuit inputs
    const input = {
        root: root.toString(),
        proposalId: proposalId.toString(),
        voteChoice: voteChoice,
        secret: secret.toString(),
        pathElements: pathElements.map(e => e.toString()),
        pathIndices: pathIndices
    };
    
    console.log("Circuit input prepared");
    
    // 5. Generate witness
    console.log("Calculating witness with SnarkJS...");
    const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        input,
        WASM_PATH,
        ZKEY_PATH
    );
    
    console.log("Proof generated successfully!");
    
    return {
        proof,
        publicSignals,
        nullifier: nullifier.toString(),
        root: root.toString()
    };
}

/**
 * Verify a proof (for testing)
 */
async function verifyProof(proof, publicSignals) {
    const vKey = JSON.parse(fs.readFileSync(VKEY_PATH));
    const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);
    return isValid;
}

/**
 * Export proof to Solidity-compatible format
 */
async function exportSolidityCallData(proof, publicSignals) {
    const calldata = await snarkjs.groth16.exportSolidityCallData(proof, publicSignals);
    
    // Parse the call data string format: "[a,b], [[c,d],[e,f]], [g,h], [i,j...]"
    // This part is tricky to parse with simple regex, better to let snarkjs handle it
    // or return the raw string for the contract call.
    return calldata;
}

// Example usage
async function main() {
    try {
        console.log("Using WASM:", WASM_PATH);
        console.log("Using ZKEY:", ZKEY_PATH);

        // Example: 5 registered voters
        const voterSecrets = [
            BigInt("123456789"),
            BigInt("987654321"),
            BigInt("555555555"),
            BigInt("111111111"),
            BigInt("999999999")
        ];
        
        // Generate commitments
        const commitments = [];
        for (const secret of voterSecrets) {
            const commitment = await generateCommitment(secret);
            commitments.push(commitment);
        }
        
        console.log("Registered voters:", commitments.length);
        
        // Voter 0 votes on proposal 1 with choice "Yes" (1)
        const voterIndex = 0;
        const voterSecret = voterSecrets[voterIndex];
        const proposalId = BigInt(1);
        const voteChoice = 1; // Yes
        
        const result = await generateVoteProof(
            voterSecret,
            proposalId,
            voteChoice,
            commitments,
            voterIndex
        );
        
        console.log("\n=== Proof Generated ===");
        console.log("Nullifier:", result.nullifier);
        
        // Verify proof
        const isValid = await verifyProof(result.proof, result.publicSignals);
        console.log("Proof valid:", isValid);
        
        // Export for Solidity
        const solidityData = await exportSolidityCallData(result.proof, result.publicSignals);
        console.log("\n=== Solidity Call Data (Copy this for Remix/Hardhat) ===");
        console.log(solidityData);
        
    } catch (error) {
        console.error("Error generating proof:", error);
        process.exit(1);
    }
}

// Run if called directly
if (require.main === module) {
    main().catch(console.error);
}

module.exports = {
    generateVoteProof,
    verifyProof,
    exportSolidityCallData
};